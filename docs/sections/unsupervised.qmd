# Unsupervised learning

* Clustering and/or dimension reduction

Trying to Cluster commune datas to:
1. Reduce dimension
2. See similarities

A regarder, est-ce qu'on fait un cluster pour les datas politques + un cluster pour les data démographiques, ou est-ce qu'on regroupe tout?

```{r}
set.seed(123)

# Clustering demographic
cols_commune_demographic <- select(df_commune, -c("REGION", "CODE_REGION","Conseil national - PLR","Conseil national - PDC", "Conseil national - PS", "Conseil national - UDC", "Conseil national - PEV/PCS", "Conseil national - PVL", "Conseil national - PBD", "Conseil national - PST/Sol.", "Conseil national - PES", "Conseil national - Petits partis de droite"))

# Scale the columns, some are total numbers, some are percentages
cols_commune_demographic <- scale(cols_commune_demographic)

# Calculate the distance matrix
dist_matrix_demographic <- dist(cols_commune_demographic, method = "minkowski")

# Perform hierarchical clustering
hclust_model_demographic <- hclust(dist_matrix_demographic, method = "ward.D")

# Create dendrogram
dend_demo <- as.dendrogram(hclust_model_demographic)
dend_demo <- color_branches(dend_demo, k = 5) #Set number of cluster to 5, to keep the same scale for all our variables

plot(dend_demo, main = "Demographics - Hierarchical Clustering Dendrogram")

df_commune$Demographic_cluster <- cutree(hclust_model_demographic, k = 5)
```

```{r}
# Clustering politics
set.seed(123)

cols_commune_politics <- select(df_commune, c("Conseil national - PLR","Conseil national - PDC", "Conseil national - PS", "Conseil national - UDC", "Conseil national - PEV/PCS", "Conseil national - PVL", "Conseil national - PBD", "Conseil national - PST/Sol.", "Conseil national - PES", "Conseil national - Petits partis de droite"))

# Scale the columns, some are total numbers, some are percentages
cols_commune_politics <- scale(cols_commune_politics)

# Calculate the distance matrix
dist_matrix_politics <- dist(cols_commune_politics, method = "minkowski")

# Perform hierarchical clustering
hclust_model_politics <- hclust(dist_matrix_politics, method = "ward.D")

# Create dendrogram
dend_pol <- as.dendrogram(hclust_model_politics)
dend_pol <- color_branches(dend_pol, k = 5) #Set number of cluster to 5, to keep the same scale for all our variables

plot(dend_pol, main = "Politics - Hierarchical Clustering Dendrogram")

df_commune$Political_cluster <- cutree(hclust_model_politics, k = 5)
```



## Tax
```{r}
set.seed(123)

# Clean data and convert to numeric
cleaned_impots <- apply(impots, 2, function(x) as.numeric(gsub("[^0-9.-]", "", x)))
cleaned_impots[is.na(cleaned_impots)] <- 0  # Replace NA values with 0

# Scale the features
scaled_impots <- scale(cleaned_impots)

# Perform k-means clustering
k <- 2  # Initial guess for the number of clusters
kmeans_model <- kmeans(scaled_impots, centers = k)

# Check within-cluster sum of squares (elbow method)
wss <- numeric(10)
for (i in 1:10) {
  kmeans_model <- kmeans(scaled_impots, centers = i)
  wss[i] <- sum(kmeans_model$withinss)
}
# plot(1:10, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")

# Adjust k based on elbow method
k <- 5  

# Perform k-means clustering again with optimal k
kmeans_model <- kmeans(scaled_impots, centers = k)

# Assign cluster labels to dendrogram
clusters <- kmeans_model$cluster

# Plot dendrogram
#colored_dend <- color_branches(dend, k = 5)
#y_zoom_range <- c(0, 80)  # Adjust the y-axis range as needed

#plot(colored_dend, main = "Hierarchical Clustering Dendrogram", horiz = FALSE, ylim = y_zoom_range)

```

```{r}
# Get the cluster centers
cluster_centers <- kmeans_model$centers

# Create a data frame with cluster centers
cluster_centers_df <- data.frame(cluster = 1:k, cluster_centers)

# Print cluster centers
print(cluster_centers_df)

# Calculate the size of each cluster
cluster_sizes <- table(kmeans_model$cluster)

# Print cluster sizes
print(cluster_sizes)

# Get the cluster labels
cluster_labels <- kmeans_model$cluster

# Convert cleaned_impots to a data frame
impots_cluster <- as.data.frame(cleaned_impots)

# Add the cluster labels to cleaned_impots
impots_cluster$cluster <- cluster_labels

rownames(impots_cluster) <- rownames(impots)

```
```{r}
# Preparing df_commune for merging with main dataset

df_commune <- select(df_commune, REGION, CODE_REGION, Demographic_cluster, Political_cluster)

# Merging 
impots_cluster <- impots_cluster %>%
  rownames_to_column("REGION")

# Joining df_commune with impots_cluster based on commune names
df_commune <- df_commune %>%
  left_join(impots_cluster[, c("REGION", "cluster")], by = "REGION")

# Renaming the 'cluster' column to 'Impots_cluster'
names(df_commune)[names(df_commune) == "cluster"] <- "Impots_cluster"


# Loop through each NA value in Impots_cluster column and match it with its closest match
for (i in which(is.na(df_commune$Impots_cluster))) {
  commune_name_na <- df_commune$REGION[i]
  closest_match <- agrep(commune_name_na, impots_cluster$REGION, max.distance = 0.1, ignore.case = TRUE)
  
  # If a match is found, replace NA with the cluster value
  if (length(closest_match) > 0) {
    df_commune$Impots_cluster[i] <- impots_cluster$cluster[closest_match[1]]
  }
}

# There are some NAs, let's inspect them
rows_with_na <- which(is.na(df_commune$Impots_cluster))

# Display the rows with NA values
df_commune[rows_with_na, ]

# Pq 2172 obs pour df commune et seulement 2131 pour impots
# Pq après avoir match l'un et l'autre il y a 32 de difference et pas 41

# --> Merge avec les codes zip (amto) et on verra depuis la

```

